/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_big.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: skuznets <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/21 17:56:25 by skuznets          #+#    #+#             */
/*   Updated: 2024/09/22 00:35:46 by skuznets         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

// Функция для нахождения минимального и максимального элементов
int find_min(t_stack *s) {
	int min = s->array[0];
	int i = 1;
	while (i < s->size) {
		if (s->array[i] < min)
			min = s->array[i];
		i++;
	}
	return min;
}

int find_max(t_stack *s) {
	int max = s->array[0];
	int i = 1;
	while (i < s->size) {
		if (s->array[i] > max)
			max = s->array[i];
		i++;
	}
	return max;
}

// Функция для создания отсортированного массива
int *create_sorted_array(t_stack *s) {
	int *arr = malloc(s->size * sizeof(int));
	int i = 0;

	while (i < s->size) {
		arr[i] = s->array[i];
		i++;
	}

	// Простая сортировка пузырьком
	int sorted = 0;
	while (!sorted) {
		sorted = 1;
		i = 0;
		while (i < s->size - 1) {
			if (arr[i] > arr[i + 1]) {
				int temp = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = temp;
				sorted = 0;
			}
			i++;
		}
	}
	return arr;
}

// Функция для нормализации стека (замена значений на индексы)
t_value_index *index_stack(t_stack *a) {
    int *sorted_arr = create_sorted_array(a);
    t_value_index *vi_array = malloc(a->size * sizeof(t_value_index));
    int i = 0;

    while (i < a->size) {
        vi_array[i].value = a->array[i];
        int j = 0;
        while (j < a->size) {
            if (a->array[i] == sorted_arr[j]) {
                vi_array[i].index = j;
                break;
            }
            j++;
        }
        i++;
    }

    free(sorted_arr);
    return vi_array;
}


// Функция для получения максимального количества бит
int get_max_bits(t_stack *a_indices) {
    int max_num = a_indices->array[0];
    int i = 1;
    while (i < a_indices->size) {
        if (a_indices->array[i] > max_num)
            max_num = a_indices->array[i];
        i++;
    }

    int max_bits = 0;
    while ((max_num >> max_bits) != 0)
        max_bits++;

    return max_bits;
}

// Функция сортировки Radix Sort для больших стеков
int sort_radix(t_stack *a, t_stack *b) {
    t_value_index *vi_array = index_stack(a);
    int max_bits;
    int i = 0;
    int j;
    int op_count = 0;
    int size = a->size;

    // Создаем новый стек для индексов
    t_stack *a_indices = malloc(sizeof(t_stack));
    a_indices->size = size;
    a_indices->array = malloc(size * sizeof(int));

    // Инициализируем стек индексов
    j = 0;
    while (j < size) {
        a_indices->array[j] = vi_array[j].index;
        j++;
    }

    max_bits = get_max_bits(a_indices);

    while (i < max_bits) {
        j = 0;
        int current_size = a_indices->size;
        while (j < current_size) {
            int num = a_indices->array[0];
            if (((num >> i) & 1) == 0) {
                do_pb(a_indices, b);
                op_count++;
            } else {
                do_ra(a_indices);
                op_count++;
            }
            j++;
        }
        while (b->size > 0) {
            do_pa(a_indices, b);
            op_count++;
        }
        i++;
    }

    // После сортировки по индексам восстанавливаем исходные значения в стеке a

    // Создаем отображение из индекса в исходное значение
    int *index_to_value = malloc(size * sizeof(int));
    for (j = 0; j < size; j++) {
        index_to_value[vi_array[j].index] = vi_array[j].value;
    }

    // Заменяем индексы в стеке a_indices на исходные значения
    for (j = 0; j < size; j++) {
        a->array[j] = index_to_value[a_indices->array[j]];
    }

    // Освобождаем память
    free(a_indices->array);
    free(a_indices);
    free(vi_array);
    free(index_to_value);
    return op_count;
}



// Функция для получения индекса элемента в отсортированном массиве
int get_index(int *sorted_arr, int size, int value) {
	int i = 0;
	while (i < size) {
		if (sorted_arr[i] == value)
			return i;
		i++;
	}
	return -1; // Элемент должен существовать в массиве
}

// Функция для проверки наличия элементов в текущем чанке
int has_elements_in_chunk(t_stack *a, int *sorted_arr, int total_size, int chunk_start, int chunk_end) {
	int i = 0;
	while (i < a->size) {
		int index = get_index(sorted_arr, total_size, a->array[i]);
		if (index >= chunk_start && index <= chunk_end)
			return 1;
		i++;
	}
	return 0;
}

// Основная функция сортировки для средних стеков
int sort_chunks(t_stack *a, t_stack *b) {
	int *sorted_arr;
	int num_chunks;
	int chunk_size;
	int total_size = a->size;
	int op_count = 0;
	int chunk_start, chunk_end;
	int current_chunk = 0;

	// Создаем отсортированный массив
	sorted_arr = create_sorted_array(a);

	// Определяем количество чанков в зависимости от размера стека
	if (total_size <= 100)
		num_chunks = 5; // Можно подобрать оптимальное значение
	else
		num_chunks = 10;

	chunk_size = total_size / num_chunks + 1;

	// Перемещаем элементы в стек B по чанкам
	while (current_chunk < num_chunks) {
		chunk_start = current_chunk * chunk_size;
		chunk_end = (current_chunk + 1) * chunk_size - 1;
		if (chunk_end >= total_size)
			chunk_end = total_size - 1;

		while (has_elements_in_chunk(a, sorted_arr, total_size, chunk_start, chunk_end)) {
			int index = get_index(sorted_arr, total_size, a->array[0]);
			if (index >= chunk_start && index <= chunk_end) {
				do_pb(a, b);
				op_count++;

				// Дополнительно: если индекс больше середины, делаем rb для оптимизации
				if (index > (chunk_start + chunk_end) / 2) {
					do_rb(b);
					op_count++;
				}
			} else {
				do_ra(a);
				op_count++;
			}
		}
		current_chunk++;
	}

	// Возвращаем элементы обратно в A из B
	while (b->size > 0) {
		int max_index = 0;
		int i = 1;

		// Находим индекс максимального элемента в B
		while (i < b->size) {
			if (b->array[i] > b->array[max_index])
				max_index = i;
			i++;
		}

		// Перемещаем максимальный элемент наверх стека B
		if (max_index <= b->size / 2) {
			while (max_index > 0) {
				do_rb(b);
				op_count++;
				max_index--;
			}
		} else {
			int steps = b->size - max_index;
			while (steps > 0) {
				do_rrb(b);
				op_count++;
				steps--;
			}
		}

		// Перемещаем максимальный элемент из B в A
		do_pa(a, b);
		op_count++;
	}

	free(sorted_arr);
	return op_count;
}

// Объединенная функция сортировки для больших стеков
int sort_big(t_stack *a, t_stack *b) {
	int op_count = 0;

	if (a->size <= 100) {
		// Используем алгоритм чанков для размеров до 100
		op_count = sort_chunks(a, b);
	} else {
		// Используем Radix Sort для размеров более 100
		op_count = sort_radix(a, b);
	}

	return op_count;
}